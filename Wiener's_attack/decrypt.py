from Crypto.Util.number import long_to_bytes 
from gmpy2 import isqrt 


n = 86279405358384779453223906449899195291906331624603122269470554553619452885784597615717643430211128508914221834757659129713919740593111851046782851288297677875411506803849063692241538897240016166912886957446266594746848119654333375169093603906765117669435751413605389130693722580094420068081625659779653502083
e = 10623200004997519400612045978649578538167371356348222190147241731241412958830870307360285094810867456755127450891230948952009616963228045075254743023208304751117390786665744839096600319849088726477405960611674688659931684734656021330756790660644428990002577620641959313641360697040237816546484242196409775255
ct = 40912182871088914484571463262053502547871657418697633978085397527420674779673424873308879848551011329003614171603315398591325630637841555667619532090941906204488201232922090611094475022070230064456835659789069273303103451053335093631334784005014042899046997942691133200320707844188322035087447255231151320141

def continued_fraction(n, d):
    if d == 0:
        return []
    q = n // d
    r = n - q * d
    return [q] + continued_fraction(d, r)


def convergents(n, d):
    hh, kk, h, k = 0, 1, 1, 0
    for x in continued_fraction(n, d):
        hh, kk, h, k = h, k, h * x + hh, k * x + kk
        yield h, k


def find_p_q(e, n):
    p, q = 0, 0
    for k, d in convergents(e, n):
        if k != 0:
            phi_n = (e * d - 1) // k
            a, b, c = 1, n - phi_n + 1, n
            delta = pow(b, 2) - 4 * a * c
            if delta >= 0:
                s1 = (-b + isqrt(delta)) // 2 * a
                s2 = (-b - isqrt(delta)) // 2 * a
                if n == s1 * s2:
                    return abs(s1), abs(s2)
    return -1, -1


p, q = find_p_q(e, n)
print("p =", p)
print("q =", q)
phi_n = (p - 1) * (q - 1)
d = pow(e, -1, phi_n)
m = pow(ct, d, n)
print("d= ", d) 
print("m =", long_to_bytes(m))
